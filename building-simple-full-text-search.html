<!DOCTYPE html>
<html lang="en">
  <head>
        <title>Saravanan's Blog - Building Simple Full Text Search</title>
      <meta charset="utf-8" />
      <meta name="generator" content="Pelican" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0">





  </head>

  <body>
      <header>
          <hgroup><h1><a href="/">Saravanan's Blog</a></h1></hgroup>
          <nav><ul>
                <li><a href="/category/distributed-systems.html" >Distributed Systems</a></li>
                <li><a href="/category/engineering-manger.html" >Engineering Manger</a></li>
                <li><a href="/category/experiments.html" >Experiments</a></li>
                <li><a href="/category/text-search.html"  aria-current="page" >Text Search</a></li>
          </ul></nav>
      </header>
      <main>
  <article>
    <header>
      <h2>
        <a href="/building-simple-full-text-search.html" rel="bookmark"
           title="Permalink to Building Simple Full Text Search">Building Simple Full Text Search</a></h2>
      
    </header>
    <h3>Full Text Search</h3>
<p>Full Text Search refers to technique of searching text across stored documents and obtaining matched results in order of the search score. When a user searches for a word or set of words across documents, the search engine has to fetch all the documents that contains one or more occurences of those search terms and return those results after scoring them according to certain criteria. One such technique is tfidf.</p>
<h3>TF-IDF</h3>
<p>TF-IDF is short for term frequencyâ€“inverse document frequency. In this method, the scoring of the result document is done by using term frequency and inverted document frequency. Term frequency refers to the number of occurences of search terms in the document. Inverted document frequency refers to the inverse of the number of documents that has the occurence of that search term.</p>
<p>Lets try to create such an engine using python. For this we can use the bbc news data corpus. </p>
<p>To search across documents first, we need to create an inverted index using those documents. Inverted index can be thought of as hash map with words as keys and list of documents that has those words as values.</p>
<h3>Building inverted index python</h3>
<p>The corpus consists of set of directories (per news category), inside the directory, we have text files. For this purpose, we can use text files from politics. We will break the text inside those files into sentences and then break them into individual words. Instead of using the words, we are using the lower cased lemma (after stemming) of those words for indexing. For this purpose, we use spacy (nlp python library).</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">spacy</span>


<span class="n">nlp</span> <span class="o">=</span> <span class="n">spacy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;en_core_web_sm&quot;</span><span class="p">)</span>
<span class="n">index</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">documents</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">index_file</span><span class="p">(</span><span class="n">file_</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">file_id</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>
    <span class="n">documents</span><span class="p">[</span><span class="n">file_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">parse_text</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">index_words</span><span class="p">(</span><span class="n">file_id</span><span class="p">,</span> <span class="n">words</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_text</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">parsed_text</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">words</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">parsed_text</span><span class="p">:</span>
        <span class="n">words</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">lemma_</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">words</span>


<span class="k">def</span> <span class="nf">index_words</span><span class="p">(</span><span class="n">file_id</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">index</span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file_id</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>    
            <span class="n">index</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">file_id</span><span class="p">]</span>
</code></pre></div>

<p>Now to search, all we have to get the search terms from user and use the inverted index to find the documents that contains them. </p>
<p>Let's slightly modify the function <code>index_words</code> so that we can also have reference to both the document and count. Using this, the term frequency required for tf-idf can be calculated. For Inverted document frequency, we can using the inverse of the length of value in the dictionary.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">index_words</span><span class="p">(</span><span class="n">file_id</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">current_count</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">word</span><span class="p">][</span><span class="n">file_id</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>    
            <span class="n">current_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">index</span><span class="p">[</span><span class="n">word</span><span class="p">][</span><span class="n">file_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>    
            <span class="n">index</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">file_id</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
</code></pre></div>

<p>Now lets build a simple function which can obtain documents for search terms and calculates the tf-idf score and returns those documents in the descending order (max score first) of tf-idf score.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>
    <span class="n">docs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">file_ids</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">num_of_docs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>
        <span class="n">docs_with_word</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_ids</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">file_id</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">docs_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">num_of_docs</span> <span class="o">/</span> <span class="n">docs_with_word</span><span class="p">)</span>
            <span class="n">doc_</span> <span class="o">=</span> <span class="n">documents</span><span class="p">[</span><span class="n">file_id</span><span class="p">]</span>
            <span class="n">docs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">score</span><span class="p">,</span> <span class="n">doc_</span><span class="p">))</span>
    <span class="n">docs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">docs</span>
</code></pre></div>

<p>We can enhance this further by storing the documents and inverted index in redis and doing the search using datastructures in redis. We can use hash map data structure for this purpose.</p>
<p>Let's create functions to create, delete documents which will store the documents and create / update the inverted index.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">spacy</span>
<span class="kn">import</span> <span class="nn">redis</span>


<span class="n">nlp</span> <span class="o">=</span> <span class="n">spacy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;en_core_web_sm&quot;</span><span class="p">)</span>
<span class="n">redis_client</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s2">&quot;172.20.0.2&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_text</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">parsed_text</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">words</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">parsed_text</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">((</span><span class="n">filter_</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="k">for</span> <span class="n">filter_</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">)):</span>
            <span class="n">words</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">lemma_</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">words</span>


<span class="k">def</span> <span class="nf">index_words</span><span class="p">(</span><span class="n">index_name</span><span class="p">,</span> <span class="n">file_id</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="n">redis_client</span><span class="o">.</span><span class="n">hset</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file_id</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">hash_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">redis_client</span><span class="o">.</span><span class="n">hincrby</span><span class="p">(</span><span class="n">hash_key</span><span class="p">,</span> <span class="n">file_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">index_file</span><span class="p">(</span><span class="n">index_name</span><span class="p">,</span> <span class="n">file_</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">file_id</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">parse_text</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">index_words</span><span class="p">(</span><span class="n">index_name</span><span class="p">,</span> <span class="n">file_id</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">words</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">remove_file</span><span class="p">(</span><span class="n">index_name</span><span class="p">,</span> <span class="n">file_</span><span class="p">):</span>
    <span class="n">file_id</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">redis_client</span><span class="o">.</span><span class="n">hget</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file_id</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">parsed_text</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">hash_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">redis_client</span><span class="o">.</span><span class="n">hdel</span><span class="p">(</span><span class="n">hash_key</span><span class="p">,</span> <span class="n">file_id</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">update_file</span><span class="p">(</span><span class="n">index_name</span><span class="p">,</span> <span class="n">file_</span><span class="p">):</span>
    <span class="n">remove_file</span><span class="p">(</span><span class="n">index_name</span><span class="p">,</span> <span class="n">file_</span><span class="p">)</span>
    <span class="n">index_file</span><span class="p">(</span><span class="n">index_name</span><span class="p">,</span> <span class="n">file_</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p>Now we can modify the above mentioned function to search for the documents stored id redis. all we have to do is to modify the function to do search in redis.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">index_name</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="n">docs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">docs_</span> <span class="o">=</span> <span class="n">redis_client</span><span class="o">.</span><span class="n">hgetall</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">num_of_docs</span> <span class="o">=</span> <span class="n">redis_client</span><span class="o">.</span><span class="n">hlen</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">docs_with_word</span> <span class="o">=</span> <span class="n">redis_client</span><span class="o">.</span><span class="n">hlen</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">doc_</span><span class="p">,</span> <span class="n">count_</span> <span class="ow">in</span> <span class="n">docs_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">file_id</span> <span class="o">=</span> <span class="n">doc_</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">count_</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">num_of_docs</span> <span class="o">/</span> <span class="n">docs_with_word</span><span class="p">)</span>
            <span class="n">doc_</span> <span class="o">=</span> <span class="p">(</span><span class="n">redis_client</span><span class="o">.</span><span class="n">hget</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">index_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file_id</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(),</span> <span class="n">score</span><span class="p">)</span>
            <span class="n">docs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">docs</span>
</code></pre></div>

<p>The above implementation is a simple one, but this can be a helpful starting point for building such search engine. 
This can be further improved by </p>
<ul>
<li>Modifying the search function to accept boolean queries (example: "President" OR "Prime Minister"). </li>
<li>Exploring further on using alternative datastructures for storing the index </li>
<li>Storing documents and indices in Disk instead of using Redis.</li>
</ul>
    <footer>
      <p>Published: <time datetime="2020-09-30T00:00:00+05:30">
        Wed 30 September 2020
      </time></p>
        <address>
          By             <a href="/author/saravanan-n.html">Saravanan N</a>
        </address>
        <p>
          Category: <a href="/category/text-search.html">Text Search</a>
        </p>
    </footer>
  </article>
      </main>
      <footer>
          <address>
            Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>,
            which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
          </address>
      </footer>
  </body>
</html>