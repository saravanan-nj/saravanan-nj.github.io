<!DOCTYPE html>
<html lang="en">
  <head>
        <title>Saravanan's Blog - Raft Consensus Algorithm</title>
      <meta charset="utf-8" />
      <meta name="generator" content="Pelican" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0">





  </head>

  <body>
      <header>
          <hgroup><h1><a href="/">Saravanan's Blog</a></h1></hgroup>
          <nav><ul>
                <li><a href="/category/distributed-systems.html"  aria-current="page" >Distributed Systems</a></li>
                <li><a href="/category/engineering-manger.html" >Engineering Manger</a></li>
                <li><a href="/category/experiments.html" >Experiments</a></li>
                <li><a href="/category/text-search.html" >Text Search</a></li>
          </ul></nav>
      </header>
      <main>
  <article>
    <header>
      <h2>
        <a href="/raft-consensus-algorithm.html" rel="bookmark"
           title="Permalink to Raft Consensus Algorithm">Raft Consensus Algorithm</a></h2>
      
    </header>
    <h2>Consensus in Distributed Systems</h2>
<p>In distributed systems, we will have multiple components running on multiple nodes which can communicate over a network, work together as a single system.
For this system to be stable and reliable, these components need to talk to each other and need to agree on certain values. For example, in a distributed database,
When we write data to it, before we save it, we need different nodes on that database to agree on the new data, so that when a read request goes to any of the available nodes, it won't return different data for the same request.</p>
<p>According to <a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)">wikipedia</a></p>
<blockquote>
<p>A fundamental problem in distributed computing and multi-agent systems is to achieve overall system reliability in the presence of a number of faulty processes. This often requires coordinating processes to reach consensus, or agree on some data value that is needed during computation.</p>
</blockquote>
<h2>Raft</h2>
<p>Raft is a consensus algorithm that tries to solve this problem without many complications. Raft protocol depends on the existence of a leader in the system to operate. Each node can be in one of the following states.</p>
<ol>
<li>Leader</li>
<li>Candidate</li>
<li>Follower</li>
</ol>
<p>Initially when the system starts, every node will be in <em>Follower</em> state. For the system to work properly as expected, there needs to be a leader. When the absence of a leader is detected, a new election is held and a new leader is elected. After this, the system can start accepting requests from clients. All the nodes will maintain an append only replication log to which it will record the incoming requests for changes to data in the system, all these changes will be sent to leader and leader will take care of propagating these changes to follower nodes.</p>
<h2>Leader Election</h2>
<p>Each election has a unique term number. After detecting the absence of the leader in the system, any node can stand for the next term and can request votes from other available nodes. Each node will wait for a random election timeout before transitioning to <em>Candidate</em> state from <em>Follower</em> state. After the timeout, the node will enter <em>Candidate</em> state, then it will send a vote request to the other nodes in the system. The vote request will have a new election term number(current term number will be increased by 1) and last commit index from its log. Before sending the vote requests, the node will vote for itself in the current term. A node can vote only once for a term, when one node receives the vote request, it will vote only for that term only if it had not previously voted for the same term and the commit index mentioned in the vote request is higher or equal to its own commit index. The node which gets the majority of votes will become the leader, if there is no majority, that election will be dropped and a new election will be held. After the node becomes leader it will start sending heartbeats to other nodes in the system indicating that it has won the election and it is the leader of the cluster for that election term. The leader node will transition to <em>Leader</em> state and other nodes in the system will transition to <em>Follower</em> state. The same procedure will be followed incase of failure of the leader node.</p>
<h2>Log Replication</h2>
<p>All the changes to the system have to go through the leader, whether it is for updating existing data or creating new data or deleting existing data. The leader will receive the request and records the changes in its log in uncommitted state against a new index and then sends <em>AppendEntry</em> request to its followers with the changes and the new index. The followers will receive the request and make the changes to its own replication log and send acknowledgement. When the leader nodes receive the acknowledgement from the majority of the nodes, the change will be marked as committed and a response will be sent to the client. After that the leader will send committed index along with the next <em>AppendEntry</em> message. The follower after receiving this message, will commit the changes and apply the changes to the data storage. When a new node joins the cluster or a follower becomes available after becoming unavailable, the replication log of that node will not be up-to-date. It is the responsibility of the leader node to replay all the missing changes and replicate them in those nodes. If any of the nodes cannot agree with any of the changes in the replication log with what is present in the leader node due to some network issues or any other kind of issues, the leader node will force that node to delete those changes and replicate the changes from the master node.</p>
<h2>Building simple key value store based on raft</h2>
<p>I tried implementing a simple distributed key value store, which uses the above raft protocol to address the consensus problem in this system.  The functionality of the key value store is simple, given a key (string) and value (string), it will write it to a single json file. I was not considering LSM and MemTable for this. Given a write request, the system needs to accept the values and write it to a json file on every single node in the system and these json files need to be in sync.</p>
<p>For communication between nodes, I used gRPC. For accepting requests from a client, a HTTP API was exposed. The client can send a write request to the leader node and can send read requests to any of the available nodes. I have written this system in python using async await, gRPC, asyncio library.</p>
<p>In this system, I decided to reuse the AppendEntry request for heartbeat. When there is a write request to the leader node, it will send AppendEntry with a message otherwise it will send empty AppendEntry messages to the follower nodes (which can be considered as heartbeat).</p>
<p>Code is available at <a href="https://github.com/saravanan-nj/raft-experiment.git">Github</a></p>
<p>We can run a node by running the <code>run.py</code> file. In that file there is a config dictionary, which can be used to mention the gRPC port, http port, data directories and other nodes present in the system.</p>
    <footer>
      <p>Published: <time datetime="2021-08-28T00:00:00+05:30">
        Sat 28 August 2021
      </time></p>
        <address>
          By             <a href="/author/saravanan-n.html">Saravanan N</a>
        </address>
        <p>
          Category: <a href="/category/distributed-systems.html">Distributed Systems</a>
        </p>
    </footer>
  </article>
      </main>
      <footer>
          <address>
            Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>,
            which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
          </address>
      </footer>
  </body>
</html>